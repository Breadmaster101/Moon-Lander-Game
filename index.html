<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Lander Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #0f0;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #050505;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Retro CRT Effect Overlay */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        .glow {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.9);
            pointer-events: none;
            z-index: 11;
        }

        /* HUD Interface */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 5px #0f0;
        }

        .telemetry-row {
            display: flex;
            gap: 20px;
            margin-bottom: 5px;
            font-size: 18px;
        }

        .label { color: #aaa; width: 120px; display:inline-block;}
        .value { color: #fff; font-weight: bold; }
        .warn { color: #f33; }
        .good { color: #0f0; }

        #messages {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            text-shadow: 0 0 10px currentColor;
        }
        
        h2 {
            font-size: 1.5rem;
            color: #aaa;
            margin-top: 10px;
        }

        .hidden { display: none; }
        
        .msg-win { color: #0f0; }
        .msg-loss { color: #f33; }
        .msg-intro { color: #fff; }

        /* Fuel Gauges */
        .fuel-label { margin-top: 8px; font-size: 14px; color:#888;}
        .fuel-box {
            border: 1px solid #444;
            width: 200px;
            height: 12px;
            position: relative;
            background: rgba(0,0,0,0.5);
        }
        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s, background-color 0.2s;
        }
        #main-fuel-bar { background-color: #0f0; }
        #rcs-fuel-bar { background-color: #fa0; }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="glow"></div>

    <!-- Heads Up Display -->
    <div id="ui-layer">
        <div class="telemetry-row">
            <span class="label">ALTITUDE:</span>
            <span id="ui-alt" class="value">0000</span>
        </div>
        <div class="telemetry-row">
            <span class="label">H. SPEED:</span>
            <span id="ui-hspeed" class="value">0000</span>
        </div>
        <div class="telemetry-row">
            <span class="label">V. SPEED:</span>
            <span id="ui-vspeed" class="value">0000</span>
        </div>
        
        <!-- Split Fuel System -->
        <div class="fuel-label">MAIN ENGINE PROPELLANT</div>
        <div class="fuel-box">
            <div id="main-fuel-bar" class="bar-fill"></div>
        </div>

        <div class="fuel-label">RCS PROPELLANT (ROTATION)</div>
        <div class="fuel-box">
            <div id="rcs-fuel-bar" class="bar-fill"></div>
        </div>
    </div>

    <!-- Game State Messages -->
    <div id="messages">
        <div id="startScreen">
            <h1 class="msg-intro">MOON LANDER GAME</h1>
            <h2>ARROW KEYS to Thrust/Rotate</h2>
            <h2>Spacebar to Start</h2>
        </div>
        <div id="winScreen" class="hidden">
            <h1 class="msg-win">THE EAGLE HAS LANDED</h1>
            <h2>Mission Success</h2>
            <h2>Spacebar to Restart</h2>
        </div>
        <div id="crashScreen" class="hidden">
            <h1 class="msg-loss">SIGNAL LOST</h1>
            <h2>Critical Failure</h2>
            <h2>Spacebar to Retry</h2>
        </div>
    </div>
</div>

<script>
/**
 * APOLLO LANDING SIMULATOR - REALISM UPDATE
 * 1. Variable Mass (Rocket Equation)
 * 2. Rotational Inertia
 * 3. Split Fuel Systems
 * 4. Vacuum Exhaust
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURATION ---
const GRAVITY = 0.0018; 
const THRUST_POWER_BASE = 0.0085; 
const ROTATION_TORQUE = 0.0002;   
const LANDING_PAD_WIDTH = 120;
const MAX_LANDING_SPEED_V = 0.6;
const MAX_LANDING_SPEED_H = 0.4;
const MAX_LANDING_ANGLE = 0.15;
const MAX_ROTATION_SPEED = 0.02;  

// Mass Properties (Rocket Equation)
const DRY_MASS = 1.0;           
const MAIN_FUEL_WEIGHT = 0.01;  
const RCS_FUEL_WEIGHT = 0.005;  

// Fuel Properties - ADJUSTED FOR EASIER DIFFICULTY
const MAIN_CONSUMPTION = 0.17; // Significantly reduced (was 0.25)
const RCS_CONSUMPTION = 0.17;  // Significantly reduced (was 0.3)

// --- GAME STATE ---
let gameState = "START"; 
let width, height;
let terrainPoints = [];
let padX = 0;
let stars = [];
let particles = [];
let groundYUnderLander = 0;

// --- ADVANCED AUDIO SYSTEM ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
let audioInitialized = false;

let engineGain, engineFilter, rumbleFilter;
let rcsGain, rcsFilter;

function createNoiseBuffer(ctx, type) {
    const bufferSize = ctx.sampleRate * 2; 
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    if (type === 'white') {
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    } else if (type === 'pink') {
        let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168981;
            data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            data[i] *= 0.11; 
            b6 = white * 0.115926;
        }
    } else if (type === 'brown') {
        let lastOut = 0;
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            lastOut = (lastOut + (0.02 * white)) / 1.02;
            data[i] = lastOut * 3.5;
            if(data[i] > 1) data[i] = 1;
            if(data[i] < -1) data[i] = -1;
        }
    }
    return buffer;
}

function initAudio() {
    if (audioInitialized) return;
    try {
        audioCtx = new AudioContext();

        // Main Engine (Deep Rumble)
        const roarSrc = audioCtx.createBufferSource();
        roarSrc.buffer = createNoiseBuffer(audioCtx, 'pink');
        roarSrc.loop = true;
        
        engineFilter = audioCtx.createBiquadFilter();
        engineFilter.type = 'lowpass';
        engineFilter.frequency.value = 100;

        const rumbleSrc = audioCtx.createBufferSource();
        rumbleSrc.buffer = createNoiseBuffer(audioCtx, 'brown');
        rumbleSrc.loop = true;

        rumbleFilter = audioCtx.createBiquadFilter();
        rumbleFilter.type = 'lowpass';
        rumbleFilter.frequency.value = 60;

        const dist = audioCtx.createWaveShaper();
        const curve = new Float32Array(44100);
        for (let i=0; i<44100; i++) {
            let x = (i / 44100) * 2 - 1;
            curve[i] = (Math.tanh(x * 5)); 
        }
        dist.curve = curve;

        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 15; 
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 50; 
        
        lfo.connect(lfoGain);
        lfoGain.connect(engineFilter.frequency);
        lfo.start();

        engineGain = audioCtx.createGain();
        engineGain.gain.value = 0;

        roarSrc.connect(engineFilter).connect(engineGain);
        rumbleSrc.connect(rumbleFilter).connect(dist).connect(engineGain);
        engineGain.connect(audioCtx.destination);
        
        roarSrc.start();
        rumbleSrc.start();

        // RCS (Sharp Hiss)
        const rcsSrc = audioCtx.createBufferSource();
        rcsSrc.buffer = createNoiseBuffer(audioCtx, 'white');
        rcsSrc.loop = true;

        rcsFilter = audioCtx.createBiquadFilter();
        rcsFilter.type = 'highpass';
        rcsFilter.frequency.value = 800;

        rcsGain = audioCtx.createGain();
        rcsGain.gain.value = 0;

        rcsSrc.connect(rcsFilter).connect(rcsGain);
        rcsGain.connect(audioCtx.destination);
        rcsSrc.start();

        audioInitialized = true;
    } catch(e) { console.error(e); }
}

function updateAudio(thrusting, rotating) {
    if (!audioInitialized) return;
    const t = audioCtx.currentTime;

    if (thrusting) {
        engineGain.gain.setTargetAtTime(1.5, t, 0.1);
        engineFilter.frequency.setTargetAtTime(600, t, 0.2);
        rumbleFilter.frequency.setTargetAtTime(120, t, 0.1);
    } else {
        engineGain.gain.setTargetAtTime(0, t, 0.05);
        engineFilter.frequency.setTargetAtTime(60, t, 0.1);
        rumbleFilter.frequency.setTargetAtTime(40, t, 0.1);
    }

    if (rotating) {
        rcsGain.gain.setTargetAtTime(0.2, t, 0.02);
    } else {
        rcsGain.gain.setTargetAtTime(0, t, 0.05);
    }
}

// --- LANDER OBJECT ---
const lander = {
    x: 0, y: 0, vx: 0, vy: 0,
    angle: -Math.PI / 2,
    angularVelocity: 0, // FEATURE: Inertia
    
    // FEATURE: Split Fuel
    mainFuel: 100,
    rcsFuel: 100,
    
    radius: 12,
    thrusting: false,
    rotatingLeft: false,
    rotatingRight: false,

    reset: function() {
        this.x = width / 2;
        this.y = height * 0.15;
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.angularVelocity = 0;
        this.mainFuel = 100;
        this.rcsFuel = 100;
        this.thrusting = false;
        this.rotatingLeft = false;
        this.rotatingRight = false;
        updateAudio(false, false);
    },

    update: function() {
        // FEATURE: Variable Mass Calculation
        // Mass = Dry Mass + (Fuel * Weight)
        let currentMass = DRY_MASS + (this.mainFuel * MAIN_FUEL_WEIGHT) + (this.rcsFuel * RCS_FUEL_WEIGHT);

        // --- Rotation Physics (Inertia) ---
        let isRotating = false;
        if (this.rcsFuel > 0) {
            if (this.rotatingLeft) {
                this.angularVelocity -= ROTATION_TORQUE / currentMass; // Heavier ship rotates slower
                this.rcsFuel -= RCS_CONSUMPTION;
                isRotating = true;
                createRCSParticles(this.x, this.y, this.angle, 'left');
            }
            if (this.rotatingRight) {
                this.angularVelocity += ROTATION_TORQUE / currentMass;
                this.rcsFuel -= RCS_CONSUMPTION;
                isRotating = true;
                createRCSParticles(this.x, this.y, this.angle, 'right');
            }
        }
        this.angle += this.angularVelocity; // Apply angular velocity to angle

        // --- Thrust Physics ---
        let isThrusting = false;
        if (this.thrusting && this.mainFuel > 0) {
            // Acceleration = Force / Mass
            let accel = THRUST_POWER_BASE / currentMass;
            
            this.vx += Math.cos(this.angle) * accel;
            this.vy += Math.sin(this.angle) * accel;
            this.mainFuel -= MAIN_CONSUMPTION;
            isThrusting = true;

            // PARTICLE SYSTEM: Vacuum Exhaust
            createThrustParticles(
                this.x - Math.cos(this.angle) * 10, 
                this.y - Math.sin(this.angle) * 10, 
                this.angle + Math.PI
            );

            createSurfaceDust();
        }
        
        updateAudio(isThrusting, isRotating);

        // Gravity
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;

        // Screen wrapping
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
    },

    draw: function() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2); 

        const scale = 1.2;

        // Draw Legs
        ctx.strokeStyle = "#d4af37"; 
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-8 * scale, 6 * scale);
        ctx.lineTo(-14 * scale, 14 * scale);
        ctx.lineTo(-16 * scale, 14 * scale); 
        ctx.moveTo(-14 * scale, 14 * scale);
        ctx.lineTo(-12 * scale, 14 * scale);
        ctx.moveTo(8 * scale, 6 * scale);
        ctx.lineTo(14 * scale, 14 * scale);
        ctx.lineTo(16 * scale, 14 * scale); 
        ctx.moveTo(14 * scale, 14 * scale);
        ctx.lineTo(12 * scale, 14 * scale);
        ctx.stroke();

        // Draw Descent Stage
        ctx.fillStyle = "#C68908"; 
        ctx.fillRect(-8 * scale, -2 * scale, 16 * scale, 10 * scale);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(-8 * scale, -2 * scale, 16 * scale, 10 * scale);

        // Draw Ascent Stage
        ctx.fillStyle = "#ccc";
        ctx.beginPath();
        ctx.moveTo(-6 * scale, -2 * scale);
        ctx.lineTo(-8 * scale, -6 * scale);
        ctx.lineTo(-5 * scale, -10 * scale);
        ctx.lineTo(5 * scale, -10 * scale);
        ctx.lineTo(8 * scale, -6 * scale);
        ctx.lineTo(6 * scale, -2 * scale);
        ctx.fill();
        
        // Windows
        ctx.fillStyle = "#112";
        ctx.beginPath();
        ctx.moveTo(-4 * scale, -7 * scale);
        ctx.lineTo(-1 * scale, -6 * scale);
        ctx.lineTo(-1 * scale, -4 * scale);
        ctx.lineTo(-5 * scale, -5 * scale);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(4 * scale, -7 * scale);
        ctx.lineTo(1 * scale, -6 * scale);
        ctx.lineTo(1 * scale, -4 * scale);
        ctx.lineTo(5 * scale, -5 * scale);
        ctx.fill();

        // RCS Nozzles
        ctx.fillStyle = "#888";
        ctx.fillRect(-9 * scale, -7 * scale, 2, 2);
        ctx.fillRect(7 * scale, -7 * scale, 2, 2);

        ctx.restore();
    }
};

// --- PARTICLE SYSTEM ---
class Particle {
    constructor(x, y, vx, vy, life, color, size) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = size || 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

function createThrustParticles(x, y, angle) {
    // FEATURE: Vacuum Exhaust
    // In a vacuum, gas expands rapidly sideways (wide cone)
    // and becomes invisible quickly (low opacity/life)
    
    for(let i=0; i<3; i++) {
        // Much wider spread (1.2 radians) compared to atmosphere
        let spread = (Math.random() - 0.5) * 1.5; 
        let speed = 3 + Math.random() * 2;
        let vx = Math.cos(angle + spread) * speed + lander.vx;
        let vy = Math.sin(angle + spread) * speed + lander.vy;

        // White/Blue tint for hot gas, fades fast
        particles.push(new Particle(x, y, vx, vy, 10 + Math.random()*10, '#ccf', 2));
    }
}

function createRCSParticles(x, y, angle, side) {
    let scale = 1.2;
    let offsetX = side === 'left' ? 7 * scale : -9 * scale; 
    let offsetY = -7 * scale;
    
    let rx = x + (offsetX * Math.cos(angle + Math.PI/2) - offsetY * Math.sin(angle + Math.PI/2));
    let ry = y + (offsetX * Math.sin(angle + Math.PI/2) + offsetY * Math.cos(angle + Math.PI/2));

    let ejectAngle = angle + (side === 'left' ? 0 : Math.PI);
    
    let speed = 1 + Math.random();
    particles.push(new Particle(
        rx, ry, 
        Math.cos(ejectAngle)*speed + lander.vx, 
        Math.sin(ejectAngle)*speed + lander.vy, 
        5 + Math.random()*5, 
        '#fff', 1
    ));
}

function createExplosion(x, y) {
    for(let i=0; i<60; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 3;
        particles.push(new Particle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed, 60 + Math.random() * 40, '#fff', 2));
        particles.push(new Particle(x, y, Math.cos(angle)*speed*0.5, Math.sin(angle)*speed*0.5, 80, '#f50', 3));
    }
}

function createSurfaceDust() {
    let distToGround = groundYUnderLander - lander.y;
    if (distToGround > 0 && distToGround < 150) {
        let intensity = Math.max(0, (150 - distToGround) / 10);
        for(let i=0; i<intensity; i++) {
            let dir = Math.random() > 0.5 ? 1 : -1;
            let speed = 1 + Math.random() * 3;
            particles.push(new Particle(
                lander.x + (Math.random() * 40 - 20), 
                groundYUnderLander, 
                dir * speed + lander.vx, 
                (Math.random() * -0.5), 
                30 + Math.random() * 20, 
                '#888', 
                1 + Math.random() * 2
            ));
        }
    }
}

// --- TERRAIN GENERATION ---
function generateTerrain() {
    terrainPoints = [];
    let segments = 100; 
    let segmentWidth = width / segments;
    
    let padSegmentStart = Math.floor(segments * 0.3 + Math.random() * (segments * 0.4));
    let padSegmentCount = Math.ceil(LANDING_PAD_WIDTH / segmentWidth);
    padX = padSegmentStart * segmentWidth + (padSegmentCount * segmentWidth) / 2;

    let y = height * 0.8;
    let rough = 0;

    for (let i = 0; i <= segments; i++) {
        let x = i * segmentWidth;
        
        if (i >= padSegmentStart && i <= padSegmentStart + padSegmentCount) {
            // Flat pad
        } else {
            rough = (Math.random() - 0.5) * 30;
            y += rough;
            if (y > height - 20) y = height - 20;
            if (y < height * 0.6) y = height * 0.6;
        }
        terrainPoints.push({x: x, y: y});
    }
}

function drawTerrain() {
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(0, height);
    for (let p of terrainPoints) {
        ctx.lineTo(p.x, p.y);
    }
    ctx.lineTo(width, height);
    ctx.closePath();
    ctx.fill();

    // Pad indicator
    let startX = padX - LANDING_PAD_WIDTH/2;
    let padY = terrainPoints.find(p => p.x >= startX).y;
    
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, padY);
    ctx.lineTo(padX + LANDING_PAD_WIDTH/2, padY);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
    ctx.fillRect(startX, padY, LANDING_PAD_WIDTH, -padY);
}

// --- STARFIELD ---
function initStars() {
    stars = [];
    for(let i=0; i<150; i++) {
        stars.push({
            x: Math.random() * width,
            y: Math.random() * height,
            size: Math.random() * 1.5
        });
    }
}
function drawStars() {
    ctx.fillStyle = '#fff';
    for(let s of stars) {
        ctx.fillRect(s.x, s.y, s.size, s.size);
    }
}

// --- COLLISION & UTILS ---
function checkCollision() {
    groundYUnderLander = height;
    let p1, p2;

    for (let i = 0; i < terrainPoints.length - 1; i++) {
        if (lander.x >= terrainPoints[i].x && lander.x <= terrainPoints[i+1].x) {
            p1 = terrainPoints[i];
            p2 = terrainPoints[i+1];
            let slope = (p2.y - p1.y) / (p2.x - p1.x);
            groundYUnderLander = p1.y + slope * (lander.x - p1.x);
            break;
        }
    }

    if (lander.y + 16 >= groundYUnderLander) {
        handleLanding(p1, p2);
    }
}

function handleLanding(p1, p2) {
    lander.thrusting = false;
    lander.rotatingLeft = false;
    lander.rotatingRight = false;
    updateAudio(false, false); 

    let slope = Math.abs((p2.y - p1.y) / (p2.x - p1.x));
    let isFlat = slope < 0.01;
    let safeVSpeed = Math.abs(lander.vy) < MAX_LANDING_SPEED_V;
    let safeHSpeed = Math.abs(lander.vx) < MAX_LANDING_SPEED_H;
    
    let angleDiff = Math.abs(lander.angle + Math.PI/2); 
    while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
    angleDiff = Math.abs(angleDiff);
    let safeAngle = angleDiff < MAX_LANDING_ANGLE;
    
    // Safe rotation check (can't land while spinning)
    let safeRotation = Math.abs(lander.angularVelocity) < MAX_ROTATION_SPEED;

    if (isFlat && safeVSpeed && safeHSpeed && safeAngle && safeRotation) {
        gameState = "LANDED";
        lander.y = groundYUnderLander - 16;
        lander.vy = 0;
        lander.vx = 0;
        lander.angularVelocity = 0;
        document.getElementById('winScreen').classList.remove('hidden');
    } else {
        gameState = "CRASHED";
        createExplosion(lander.x, lander.y);
        document.getElementById('crashScreen').classList.remove('hidden');
    }
}

// --- GAME LOOP ---
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    if(gameState === "START") {
        initStars();
        generateTerrain();
    }
}
window.addEventListener('resize', resize);

function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    drawStars();
    drawTerrain();

    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    if (gameState === "PLAYING") {
        checkCollision(); 
        lander.update();
        lander.draw();
        updateUI();
    } else if (gameState === "LANDED") {
        lander.draw();
    }

    requestAnimationFrame(loop);
}

// --- UI UPDATES ---
const uiAlt = document.getElementById('ui-alt');
const uiHSpeed = document.getElementById('ui-hspeed');
const uiVSpeed = document.getElementById('ui-vspeed');
const uiMainBar = document.getElementById('main-fuel-bar');
const uiRcsBar = document.getElementById('rcs-fuel-bar');

function updateUI() {
    let alt = Math.max(0, Math.floor((groundYUnderLander - (lander.y + 16)) * 10));
    let vSpeed = (lander.vy * 100).toFixed(0);
    let hSpeed = (lander.vx * 100).toFixed(0);

    uiAlt.innerText = alt.toString().padStart(4, '0');
    uiHSpeed.innerText = Math.abs(hSpeed).toString().padStart(3, '0');
    uiHSpeed.className = "value " + (Math.abs(lander.vx) > MAX_LANDING_SPEED_H ? "warn" : "good");
    uiVSpeed.innerText = (-vSpeed).toString().padStart(3, '0');
    uiVSpeed.className = "value " + (Math.abs(lander.vy) > MAX_LANDING_SPEED_V ? "warn" : "good");

    // Update Split Fuel Bars
    uiMainBar.style.width = Math.max(0, lander.mainFuel) + "%";
    if (lander.mainFuel < 20) uiMainBar.style.backgroundColor = "#f33";
    else uiMainBar.style.backgroundColor = "#0f0";

    uiRcsBar.style.width = Math.max(0, lander.rcsFuel) + "%";
    if (lander.rcsFuel < 20) uiRcsBar.style.backgroundColor = "#f33";
    else uiRcsBar.style.backgroundColor = "#fa0";
}

// --- CONTROLS ---
window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
        initAudio();
        if(audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        if (gameState !== "PLAYING") {
            gameState = "PLAYING";
            lander.reset();
            generateTerrain();
            particles = [];
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            document.getElementById('crashScreen').classList.add('hidden');
        }
    }

    if (gameState === "PLAYING") {
        if (e.code === 'ArrowUp') lander.thrusting = true;
        if (e.code === 'ArrowLeft') lander.rotatingLeft = true;
        if (e.code === 'ArrowRight') lander.rotatingRight = true;
    }
});

window.addEventListener('keyup', e => {
    if (e.code === 'ArrowUp') lander.thrusting = false;
    if (e.code === 'ArrowLeft') lander.rotatingLeft = false;
    if (e.code === 'ArrowRight') lander.rotatingRight = false;
});

// --- INIT ---
resize();
requestAnimationFrame(loop);

</script>
</body>
</html>
